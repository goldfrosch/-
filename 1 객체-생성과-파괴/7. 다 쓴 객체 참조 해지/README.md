# 다 쓴 객체 참조를 해지하라

메모리 누수의 발생

Java의 가비지 컬렉션만 믿고 메모리 관리에 신경을 안쓰면 안된다.

```
  public class Stack {
    ...
      public Object pop() {
          if (size == 0)
              throw new EmptyStackException();
          return elements[--size];
      }
    ...
  }
```

해당 코드는 스택의 pop() 메소드를 구현한 코드이다.

코드에는 특별한 문제가 없고 별의별 테스트를 수행하도 잘 통과될 것이지만. 스택을 사용하는 프로그램을 오랫동안 실행하다보면 가비지 컬렉션 활동과 메모리 사용량이 늘어나 결국 성능이 저하된다.

거의 없지만 디스크 페이징이나 OutOfMemoryError를 일으켜서 프로그램이 예기치 않게 종료되기도 한다.

수정을 해야한다면

```
  public Object pop() {
    if (size == 0) {
      throw new EmptyStackException();
    }

    Object result = elements[--size];
    elements[size] = null;
    return result;
  }
```

다 사용한 참조를 null로 처리하게 될경우에는 다 처리한 참조를 실수로 사용하게 될때 NPE를 던지며 종료된다.

미리 null로 처리하지 않았다면 무언가 잘못 처리할 수가 있어서 모든 다 사용한 참조를 null로 처리하는데 집중을 하는 프로그래머들도 있지만 코드를 쓸데없이 더 지저분하게 만드는 작업이 되기에 가장 효율적인 방법은 참조를 담은 변수를 유효 범위 밖으로 밀어내는 것이다.

Stack 클래스가 메모리 누수에 취약한 이유는 자기 메모리를 직접 관리하기 때문이다.

이 스택은 elements 배열로 저장소 풀을 만들어 원소를 관리하고 배열의 활성 영역에 속한 원소들이 사용되고 비활성 영역은 사용되지 않으나 가비지 컬렉터가 이를 인식하지 못하는 것에 있다.

비활성 영역이 되었다라는 것은 프로그래머만 알고있기에 반드시 다 사용한 원소는 null로 처리를 해줘야 하는 것이다.

캐시도 메모리 누수를 일으키는 주범이다.

객체 참조를 캐시에 넣어두고 그 사실을 잊은 채 객체를 다 쓴 뒤에도 한참을 그냥 놔두는 일을 자주 접할 수 있는데, 캐시 외부에서 키를 참조하는 동안에는 WeakHashMap을, LinkedHashMap의 removeEldestEnty를 이용해서 쓰지 않는 엔트리를 청소해주는 방법을 이용한다. 더 복잡한 캐시를 만들려면 java.leng.ref를 활용하는 것 도 방법이다.
